# 동영상 입출력

```python
import cv2

video_file = "../cv_images/video.mp4"

cap = cv2.VideoCapture(video_file)      #  video_file의 첫 프레임을 읽어 동영상 캡쳐 객체 생성

if cap.isOpened():                      # 캡쳐 객체 초기화 확인
    while True:
        ret, img = cap.read()          # 다음 프레임 읽기      
        if ret:                        # 프레임 읽기 정상
            resized_img = cv2.resize(img, dsize=None, fx=0.5,fy=0.5) # 프레임 크기 조정
            cv2.imshow(video_file, img) # 화면에 표시
            cv2.waitKey(10)             # 25ms 지연(40fps로 가정)  
        else:                          # 다음 프레임 읽을 수 없슴,
            break                      # 재생 완료
else:

    print("can't open video.")          # 캡쳐 객체 초기화 실패
    
cap.release()                  # 자원 해제
cv2.destroyAllWindows()        # 모든 창 닫기
```
- index = 0 시스템 기본 카메라
   - 카메라가 열렸는지 확인  
	    if not cap.isOpened():      
	        print("Camera open failed!") # 열리지 않았으면 문자열 출력  
	        sys.exit()
    - ret, frame = cap.read() # 두 개의 값을 반환하므로 두 변수 지정  
    - return value -true/false    
	    if not ret: # 새로운 프레임을 못받아 왔을 때 braek  
	        break
# 도형그리기

### 빈 스케치북 만들기

- 크기와 초깃값으로 생성        
	Numpy 배열을 생성할 때 사용할 값을 가지고 있지 않은 경우가 많기 때문에 초기 값을 지정해서 생성하는 방법을 사용

    - `numpy.empty(shape [, dtype]) : 초기화되지 않는 값(쓰레기 값)으로 배열 생성

    - `numpy.zeros(shape [,dtype]) : 0으로 초기화된 배열 생성

    - `numpy.ones(shape [,dtype]) : 1로 초기화된 배열 생성

    - `numpy.full(shape, fill_value [,dtype]) : fill_value로 초기화된 배열 생성  

- 시퀀스와 난수로 생성
	Numpy 배열을 생성하는 방법 중에는 일정한 범위 내에서 순차적인 값을 갖게하는 방법과 난수로 채우는 방법

    - `numpy.arange([start=0, ] stop [, step=1, dtype = float64]) : 순차적인 값으로 생성
        - `start : 시작 값
        - `stop : 종료 값, 범위에 포함되는 수는 ~ stop -1
        - `step : 증가 값
        - `dtype : 데이터 타입

    - numpy.random.rand(array크기) : 
	    - 0과 1 사이의 무작위 수 생성 array크기를 생략하면 난수 1개 반환, 나머지는 해당 크기만큼 값을 반환
    - numpy.random.randn(array크기) : 표준 정규 분포를 따르는 무작위 수 생성

```python
import cv2
import numpy as np

# 세로 480 x 가로 640 , 3 channel 에 해당하는 스케치북 만들기
img = np.zeros((480, 640, 3), dtype=np.uint8)
```

```python
import cv2
import numpy as np

# 세로 480 x 가로 640 , 3 channel 에 해당하는 스케치북 만들기

img = np.zeros((480, 640, 3), dtype=np.uint8)                           # 현재 0 으로 채워져서 검정색
#img[:] = (255, 255, 255)  # 전체 공간을 흰색으로 채우기 - opencv BGR
#img[:] = (255, 0, 0)      # 전체 공간을 파란색으로 채우기
img[:] = (0, 0, 255)      # 전체 공간을 빨간색으로 채우기

cv2.imshow('img', img)
cv2.waitKey(0)
cv2.destroyAllWindows()
```
### 일부 영역 색칠

```python
import cv2
import numpy as np

# 세로 480 x 가로 640 , 3 channel 에 해당하는 스케치북 만들기

img = np.zeros((480, 640, 3), dtype=np.uint8)
img[100:200, 200:300] = ( 0, 0, 255)
img[400:420, 100:150] = ( 255, 0, 255)

# 세로영역, 가로 영역 기준으로 원하는 색을 채움

cv2.imshow('img', img)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

### 직선
>[!직선의 종류]
>
	1. cv2.LINE_4 : 상하좌우 4 방향으로 연결된 선
	2. cv2.LINE_8 : 대각선을 포함한 8방향으로 연결된 선(기본값)
	3. cv2.LINE_AA : 부드러운 선 (anit-aliasing)
```python
import cv2
import numpy as np

img = np.zeros((480, 640, 3), dtype=np.uint8)

COLOR = ( 0, 255, 255) # BGR : yellow
THICKNESS = 3 # 두께

cv2.line(img,   (50,100), (400, 50), COLOR, THICKNESS, cv2.LINE_8)
    # 그릴 위치, 시작점, 끝 점, 색깔, 두께, 선 종류
cv2.line(img, (50,200), (400, 150), COLOR, THICKNESS, cv2.LINE_4)
cv2.line(img, (50,300), (400, 250), COLOR, THICKNESS, cv2.LINE_AA)

cv2.imshow('img', img)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

### 원
```python
import cv2
import numpy as np

img = np.zeros((480, 640, 3), dtype=np.uint8)

COLOR = (255, 255, 0) # BGR : 옥색
RADIUS = 50       # 반지름
THICKNESS = 10    # 두께

cv2.circle(img, (200,100), RADIUS, COLOR, THICKNESS, cv2.LINE_AA)  # 속이 빈 원
# 그릴 위치, 원의 중심점, 반지름 색깔, 두께, 선 종류
cv2.circle(img, (400,100), RADIUS, COLOR, cv2.FILLED, cv2.LINE_AA) # 속이 꽉 찬 원
  
cv2.imshow('img', img)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

### 사각형
```python
import cv2
import numpy as np

img = np.zeros((480, 640, 3), dtype=np.uint8)

COLOR = (0, 255, 0) # BGR : 녹색
THICKNESS = 3    # 두께

cv2.rectangle(img, (100,100), (200, 200), COLOR, THICKNESS)  # 속이 빈 사각형
# 그릴 위치 (왼쪽 위 좌표, 오른쪽 아래 좌표), 색깔, 두께
cv2.rectangle(img, (300,100), (400, 300), COLOR, cv2.FILLED)   # 속이 꽉 찬 사각형

cv2.imshow('img', img)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

### 다각형
```python
import cv2
import numpy as np

img = np.zeros((480, 640, 3), dtype=np.uint8)
  
COLOR = (0, 0, 255) # BGR : 빨간색
THICKNESS = 3    # 두께
  
pts1 = np.array([[100, 100],[200,100],[100,200]])
pts2 = np.array([[200, 100],[300,100],[300,200]])

  

# True 는 다각형이 닫힘, False 다각형이 열림
# cv2.polylines(img,[pts1], True, COLOR, THICKNESS, cv2.LINE_AA) # 다각형 값을 리스트에 넣어야함
# cv2.polylines(img,[pts2], True, COLOR, THICKNESS, cv2.LINE_AA) # 다각형 값을 리스트에 넣어야함

cv2.polylines(img, [pts1 , pts2], True, COLOR, THICKNESS, cv2.LINE_AA) # 속이 빈 다각형

# 그릴위치 , 그릴 좌표, 닫힘 여부, 색깔, 두께, 선 종류
pts3 = np.array([[[100, 300], [200, 300], [100, 400]],[[200, 300], [300, 300], [300, 400]]])
cv2.fillPoly(img, pts3, COLOR, cv2.LINE_AA)
# 그릴 위치, 그릴 좌표들, 색깔, 선 종류
  
cv2.imshow('img', img)

cv2.waitKey(0)
cv2.destroyAllWindows()
```


# 텍스트
	-  cv2.putText(img, 'Coding Simplex', (20, 50), cv2.FONT_HERSHEY_SIMPLEX, SCALE, COLOR, THICKNESS)
	- 그릴 위치, 텍스트 내용, 시작위치, 폰트 종류, 크기, 색깔, 두께

### OpenCV에서 사용하는 글꼴 종류

	1. cv2.FONT_HERSHEY_SIMPLEX : 보통 크기의 산 세리프(sans-serif)글꼴
	2. cv2.FONT_HERSHEY_PLAIN : 작은 크기의 산 세리프 글꼴
	3. cv2.FONT_HERSHEY_SCRIPT_SIMPLEX : 필기체 스타일 글꼴
	4. cv2.FONT_HERSHEY_TRIPLEX : 보통 크기의 산 세리프 글꼴
	5. cv2.FONT_ITALIC : 기울림(이탤릭체)

```python
import numpy as np
import cv2

img = np.zeros((480, 640, 3), dtype=np.uint8)

COLOR = (255, 255, 255) # 흰색
THICKNESS = 1     # 두께
SCALE = 1         # 크기

# 그릴 위치, 텍스트 내용, 시작위치, 폰트 종류, 크기, 색깔, 두께
cv2.putText(img, 'Coding Simplex', (20, 50), cv2.FONT_HERSHEY_SIMPLEX, SCALE, COLOR, THICKNESS)

cv2.putText(img, 'Coding Simplex', (20, 150), cv2.FONT_HERSHEY_PLAIN, SCALE, COLOR, THICKNESS)
cv2.putText(img, 'Coding Simplex', (20, 250), cv2.FONT_HERSHEY_SCRIPT_SIMPLEX, SCALE, COLOR, THICKNESS)
cv2.putText(img, 'Coding Simplex', (20, 350), cv2.FONT_HERSHEY_TRIPLEX, SCALE, COLOR, THICKNESS)
cv2.putText(img, 'Coding Simplex', (20, 450), cv2.FONT_HERSHEY_TRIPLEX | cv2.FONT_ITALIC, SCALE, COLOR, THICKNESS) # 이탤릭체는 같이 사용

cv2.imshow('img', img)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

### 한글지원안됨

```python
import numpy as np
import cv2

img = np.zeros((480, 640, 3), dtype=np.uint8)

COLOR = (255, 255, 255) # 흰색
THICKNESS = 1     # 두께
SCALE = 1         # 크기

cv2.putText(img, '코딩', (20, 50), cv2.FONT_HERSHEY_SIMPLEX, SCALE, COLOR, THICKNESS)
# 그릴 위치, 텍스트 내용, 시작위치, 폰트 종류, 크기, 색깔, 두께

cv2.imshow('img', img)
cv2.waitKey(0)
cv2.destroyAllWindows()
```


### 한글 나타내기 - 우회 방법

```python
import numpy as np
import cv2

# PIL ( Python Image Library)
from PIL import ImageFont, ImageDraw, Image

def myPutText(src, text, pos, font_size, font_color):
    img_pil = Image.fromarray(src)
    draw = ImageDraw.Draw(img_pil)
    font = ImageFont.truetype('font/gulim.ttc', font_size)
    draw.text(pos, text, font=font, fill=font_color)
    return np.array(img_pil)
# OpenCV에서 한글 지원을 하지 않기 때문에 위 함수를 만들어 사용
  
img = np.zeros((480, 640, 3), dtype=np.uint8)

FONT_SIZE = 30
COLOR = (255, 255, 255) # 흰색
SCALE = 1         # 크기
THICKNESS = 1     # 두께

cv2.putText(img, 'Coding', (50, 50), cv2.FONT_HERSHEY_SIMPLEX, SCALE, COLOR, THICKNESS)
cv2.putText(img, '코딩', (50, 100), cv2.FONT_HERSHEY_SIMPLEX, SCALE, COLOR, THICKNESS) # : 이렇게하면 폰트 깨짐
# 그릴 위치, 텍스트 내용, 시작위치, 폰트 종류, 크기, 색깔, 두께
  
img1 = np.zeros((480, 640, 3), dtype=np.uint8)
img1 = myPutText(img, "코딩", (50, 150), FONT_SIZE, COLOR)  # 함수르 사용하여 한글 지원cv2.imshow('img', img)
cv2.imshow('img1', img1)
  
cv2.waitKey(0)

cv2.destroyAllWindows()
```


# 이미지 색공간 변경

### 색공간 변환하기

- `cv2.cvtColor(img, 옵션값)
    - 색상 공간 변환(Convert Color)은 본래의 색상 공간에서 다른 색상 공간으로 변환할 때 사용
    - 입력된 이미지는 8 비트, 16 비트, 32 비트의 정밀도를 갖는 배열을 사용할 수 있음
    - 데이터 값이 변경되거나 채널 순서가 변경될 수 있음
    - `COLOR_BGR2GRAY, COLOR_GRAY2BGR, COLOR_RGB2GRAY, COLOR_GRAY2RGB...
 
```python
import cv2
import numpy as np

img_file = '../cv_images/img.jpg'
img = cv2.imread(img_file)

#방법1
img2 = img.astype(np.uint16) # 코드 입력 # dtype 변경 : np,uint16  (기본값 : np.uint8)
b,g,r = cv2.split(img2)   # 코드 입력  # 채널 별로 분리
#b,g,r = img2[:,:,0], img2[:,:,1], img2[:,:,2]
gray1 = ((b + g + r)/3).astype(np.uint8)  # 코드 입력    # 평균 값 연산후 dtype 변경 : np.uint8 로로

#방법2
gray2 = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # BGR을 그레이 스케일로 변경

cv2.imshow('original', img)
cv2.imshow('gray1', gray1)
cv2.imshow('gray2', gray2)

cv2.waitKey(0)
cv2.destroyAllWindows()
```

# 관심영역

- 이미지내에서 원하는 피사체를 따로 분리하여 특정 처리를 하고싶을 때 사용하는 방법
- 연산할 데이터의 양을 줄이고 수행 시간을 단축시키는 때문에 이미지에 특정 연산을 적용해 새로운 이미지와 정보를 획득할 때 전체 이미지로 연산을 하는 것보다 관심이 있는 부분만 연산하는 것이 효과적임
### 1. Numpy 이용한 ROI 지정
```python
import cv2
import numpy as np
import matplotlib.pyplot as plt

img = cv2.imread('../cv_images/dog_backpack.png') # read BGR format image

rgb_img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) # convert RGB format
plt.imshow(rgb_img)
plt.show()

print(img.shape)
h=img.shape[0]; w=img.shape[1]

x=280; y=250;

roi = rgb_img[y:y+130, x:x+170]
print(roi.shape)

plt.imshow(roi) # print roi
plt.show()
```


### 2. 함수 활용하여 ROI 지정

- `cv2.selectROI([win_name,], img[,showCrossHair=True, fromCenter=False])`
    - win_name : ROI 선택을 진행할 창의 이름
    - img : ROI 선택을 진행할 이미지
    - showCrossHair : 선택 영역 중심에 십자 모양 표시 여부
    - fromCenter : 마우스 시작 지점을 영역의 중심으로 지정
    - ret : 선택한 영역 좌표와 크기
```python
# 이미지에 표시된 창에서 마우스를 사용하여 ROI선택 후 'enter' 키 / 취소하려면 'c'

import cv2
import numpy as np
import matplotlib.pyplot as plt

img = cv2.imread('../cv_images/dog_backpack.png')
x,y,w,h = cv2.selectROI('img', img, False)

if w and h:
    roi = img[y:y+h, x:x+w]
    cv2.imshow('cropped', roi)
    cv2.moveWindow('cropped', 0, 0)
    cv2.imwrite('./cropped2.jpg', roi) # 저장
    cv2.waitKey()
    cv2.destroyAllWindows()  

roi = cv2.cvtColor(roi,cv2.COLOR_BGR2RGB)
plt.imshow(roi)
plt.show()
```

# 이미지 연산

### 1. 두 영상 합성

```python
from IPython.core.pylabtools import figsize
import cv2
import numpy as np
import matplotlib.pylab as plt

  

# 이미지 읽기
img1 = cv2.imread('../cv_images/dog.jpg')
img2 = cv2.imread('../cv_images/cat.jpg')

  

# img1의 크기를 img2와 동일하게 조정
img1_resized = cv2.resize(img1, (img2.shape[1], img2.shape[0]))

# 이미지 더하기
img3 = img1_resized + img2  # 더하기 연산
img4 = cv2.add(img1_resized, img2)  # OpenCV 함수

imgs = {'img1': img1_resized, 'img2': img2, 'img1+img2': img3, 'cv.add(img1, img2)': img4}

  

# 이미지 출력
fig = plt.figure(figsize=(10, 8))
for i, (k, v) in enumerate(imgs.items()):
    plt.subplot(221+i)
    plt.axis('off')
    plt.imshow(v[:, :, ::-1])
    plt.title(k)

plt.show()
```


### 비트와이즈(bitwise) 연산
- `bitwise_and(img1, img2, mask=None) : 각 픽셀에 대한 비트와이즈 AND 연산
- `bitwise_or(img1, img2, mask=None) : 각 픽셀에 대한 비트와이즈 OR 연산
- `bitwise_xor(img1, img2, mask=None) : 각 픽셀에 대한 비트와이즈 XOR 연산
- `bitwise_not(img1, mask=None) : 각 픽셀에 대한 비트와이즈 NOT 연산
```python
import numpy as np, cv2
import matplotlib.pylab as plt

# height: 200 width: 400 검정색 이미지 생성
img1 = np.zeros((200,400), dtype=np.uint8)
img2 = np.zeros((200,400), dtype=np.uint8)

# img[y슬라이싱, x슬라이싱]
img1[:, :200] = 255     # 왼쪽은 흰색, 오른쪽은 검정
img2[100:200, :] = 255      # 위쪽은 검정색, 아래쪽은 흰색

# 비트와이즈 연산
bitAnd = cv2.bitwise_and(img1, img2)
bitOr = cv2.bitwise_or(img1, img2)
bitXor = cv2.bitwise_xor(img1, img2)
bitNot = cv2.bitwise_not(img1)

# 결과 출력
imgs = {'img1':img1, 'img2':img2, 'and':bitAnd,
          'or':bitOr, 'xor':bitXor, 'not(img1)':bitNot}

fig = plt.figure(figsize=(10, 8))

for i, (title, img) in enumerate(imgs.items()):
    plt.subplot(3,2,i+1)
    plt.title(title)
    plt.imshow(img, 'gray')
    plt.xticks([]); plt.yticks([])

plt.show()
```
# 임계처리

